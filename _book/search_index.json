[
["index.html", "Quality Assurance of Code Preface How to get the most out of this book Structure of the book Acknowledgments", " Quality Assurance of Code Quality Centre, Best Practice and Impact Division Last updated: 2020-04-02 Preface This is an early draft of Government Statistical Service (GSS) guidance. It forms part of the quality assurance guidance published by the Best Practice and Impact team, Office for National Statistics. This guidance has been created to support analysts in government who use coding in their work, for example in production of statistics, modeling or data science. Slack: GSS, Gov Data Science Twitter: GSS Good Practice Team, UK GSS Email us: gsshelp@statistics.gov.uk How to get the most out of this book This guidance is tailored to government analysts that would like to quality assure their code and assure that their work is reproducible. However, the practices outlined in the book are general to all applications of programming, so may also be insightful for those outside of government. This book might be most useful for you if you are: writing code to automate part of your work developing a statistical production pipeline and would like to assure that it is long term sustainable and reproducible developing models and would like to assure that they are transparent and reproducible looking for a high level introduction to software engineering practices This book may be most useful when used as a reference. The start of each chapter describes the risks which those practices may help to address. Therefore, you should strive to apply the most appropriate practices given the risks associated with your work. The book aims to be language agnostic and is not a comprehensive learning resource, so you may often need to study further resources to implement these practices. Suitable references are provided for python and R, as a common pair of open source languages applied across government. Structure of the book The content of the book is ordered roughly in increasing difficulty. Within each chapter, the content is also broken down into sections that gradually increase in difficulty. Acknowledgments Much of the content in this book has been adapted from the Turing Way, a guide to reproducible data science produced by the The Turing Institute. "],
["chapter-title.html", "Chapter 1 Chapter title 1.1 Introduction 1.2 Easiest chapter section 1.3 Harder chapter section 1.4 Hardest chapter section", " Chapter 1 Chapter title 1.1 Introduction 1.1.1 Prerequisites Awareness of the following will help your understanding of this chapter: - reference chapter 1.1.2 Motivation test img 1.2 Easiest chapter section 1.3 Harder chapter section 1.4 Hardest chapter section "],
["core-principles.html", "Chapter 2 Core Principles 2.1 Introduction 2.2 Motivation 2.3 Modular Code 2.4 Clean Code 2.5 Keep It Simple and Straightforward (KISS) 2.6 SOLID Software Design", " Chapter 2 Core Principles 2.1 Introduction The principles outlined in this chapter represent good practices in general programming and software development. Before reading this chapter, you would benefit from having an understanding of basic programming, including awareness of functions and objects (classes). These topics are lightly introduced, but assume familiarity with core programming techniques. 2.2 Motivation You can’t be available and responsible for long term maintenance of every piece of code that you write; others will inevitably use and likely need to adapt your code in the future. Therefore, it is important to ensure that other programmers can quickly and easily understand the task that your code performs. Many programs perform a task correctly, but are deemed to be “black boxes” because of the barrier to understanding them. It is your responsibility not to put this barrier in place. This chapter aims to highlight good coding practices that will increase the readability, and therefore maintainability, of your code. 2.3 Modular Code Breaking your code down into smaller, more manageable chunks is a sure fire way of increasing its readability. Code comes in many shapes and sizes. A few code abstractions are outlined below, which will be useful for understanding concepts throughout the rest of this chapter and book. Functions a unit of code that performs a minimal number of tasks (one ideally) can take inputs and can return outputs, though both are optional used in functional programming Figure 2.1: Visual representation of a function Objects (often defined as classes) can have associated attributes (variables that belong to the object) can have associated methods (functions that belong to the object) maintain association between data (stored in the object’s attributes) and a particular set of tasks (the object’s methods) the basis of object-orientated programming (OOP) Figure 2.2: Demonstration of a Pokémon class, with an example object (instance of the class) Scripts text documents containing source code may be broken down into sections or “chunks” may contain functions, classes and/or lines of non-modular code Packages collections of code that perform related tasks may be sub-sectioned into modules that perform related, but lower level groups of tasks contains other useful information about the code in the package (see Packaging) 2.4 Clean Code Code with high readability is often referred to as “Clean Code”. “Programs are meant to be read by humans and only incidentally for computers to execute.” — Donald Knuth, The Art of Computer Programming 2.4.1 Naming Perhaps the most important aspect of clean code is the naming of identifiers within your code - including variables, functions and classes. Someone reading your code will benefit greatly if you use names that are: informative and not misleading concise but not cryptic 2.4.1.1 Variables You may have previously come across code that contains variable names that are meaningless, or that infer an incorrect purpose: x = &quot;Sioban&quot; y = 42 z = Car() my_favourite_number = &quot;ssh, I&#39;m a string&quot; Another developer, or even yourself in two day’s time, would be unable to correctly infer what you intended these variable names to represent. Using single letters to name variables may be suitable when they are representing well-known mathematical entitites (e.g. y = mx + c), but should otherwise be avoided. Figure 2.3: Gandalf regrets writing poor quality code Using variable names that contain a few (generally 1-3) informative words can drastically improve the readability of your code: # Define variables first_name = &quot;Sioban&quot; number_of_attendees = 42 my_car = Car() # Use variables print(&quot;Hi &quot; + user_name) number_of_attendees += 1 my_car.clean() Note that the purpose of these variables is clear from their name alone. Additionally, the variable names make sense in the context that are used later on in the code. This often removes the need for explanatory comments, as your logic can be intepreted from the code itself. Naming is also very important for distguishing between similar variables. It can be tempting to use a incrementing number or character to reflect these differences, however, these identifiers are not informative. letters1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] letters2 = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] Here it is not apparent what makes letters1 different to letters2. Variable names can instead be used to document differences between variables, or describe changes made to a variable. first_three_letters = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] last_three_letters = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] first_three_letters_reversed = reversed(first_three_letters) Here the differences between the two initial lists is clear. It is also clear how the third, new list relates to the first list that was created. 2.4.1.2 Functions When naming functions, you should consider your user’s point of view (even if the user is yourself in the future). Your user should be able to infer the purpose or action of the function from the name of the function. If it is not possible to describe the overall task performed by the function in a few words, then it may be that your function is overly complex. You might consider breaking the function down into a number of smaller functional units. Where a function performs a specific task, it can be effective to describe this task in the function name, starting with a verb like so: def peel_potato(vegetable): if vegetable == &quot;potato&quot;: return &quot;peeled_potato&quot; else: raise ValueError(&quot;That&#39;s not a potato!&quot;) prepared_potato = peel_potato(&quot;potato&quot;) Sometimes a function might be used to provide a Boolean response to a decision. In this case, it might be appropriate to name a function as a question that is being posed. def is_clean(car): if car.cleanliness &gt; 5: return True else: return False if is_clean(my_car): print(&quot;Nice!&quot;) 2.4.1.3 Classes and Objects Class and object names should be concise and descriptive, like variable names. class SportsCar(Car): def clean(self): self.cleanliness = 10 print(&quot;Squeak&quot;) def drive(self): print(&quot;VROOOOM!&quot;) my_fast_car = SportsCar() 2.4.2 Code Style When the syntax of a programming language is not strict (as with python and R), it can be difficult to know how to “correctly” format your code. Code style guides provide a standard or convention to work towards, with the intention of increase consistency across a programming community. Following an established or agreed (within a team, for example) style guide will improve your ability to read other peoples code and vice versa. They might include how to appropriately: - comment or document your code - separate elements of your code with whitespace - follow naming conventions Figure 2.4: Code Quality, from xkcd However, you should not code in fear of breaching style guidance or showing a little flair in your programming style. Indeed, these guides cannot account for every possibility and may decrease readability of code is some circumstances. In any case, use your best judgement. Above all else, you should strive to be consistent in your style. Even if another programmer takes a dislike to your use of whitespace or mixedCase, if you use that style consistently throughout your script, project or code in general then they will soon get used to it. PEP8 is widely used to style Python code. While the Google style guide is often used for R, which expands on the tidyverse style guide. 2.4.2.1 Checking Code Style Manually checking that your code complies with a given style is laborious and arguably a waste of your time - programmers like to automate things after all. Two types of tool exist, which automate validation and repair of code style: - Linters - these analyse your code to flag sylistic errors (and sometimes bugs or security issues too) - Formatter - these not only detect when you have diverged from a style, but will automatically correct the formatting of your code Table 2.1: Packages that can be used for linting or formatting in Python and R Language Linters Formatters Python flake8, pylint, Bandit Black, Isort R lintr formatR, styler Be sure to read the documentation for any of these tools, to understand what they are checking/changing in your code. Many of them can be configured to ignore or detect specific types of errors. There’s also nothing to stop you from running multiple of these, to catch a broaded range of stylistic or programmatic errors. If you’re considering using these tools as part of a project, see Continuous Integration for advice on automating the running of these tools. 2.5 Keep It Simple and Straightforward (KISS) “Make everything as simple as possible, but not simpler” — Albert Einstein, maybe The KISS principle applies to all forms of communication, including coding. You are aiming to communicate a complex series of steps to your reader. Keeping the overall design of your code simple will improve the clarity of this communication. You’ll notice that many principles that support good programming practices share this common theme - simplicity. Simple programs are more likely to run, while any bugs in their code will be easier to track down. While you should strive towards simplicity, this should not compromise the usability of your code. It should still perform the desired task, just in a way that is no more complex than necessary. 2.5.1 Don’t Repeat Yourself (DRY) Repetition not only wastes your time, writing redundant lines of code, but it makes code more difficult to read and maintain. Consider a script that contains three copies of a similar piece of code. If the code that is used to perform the repetitive task is found to be incorrect, or if a developer wishes to modify the task being performed by this code, a similar change must be implemented in each of the three copies. first_ten_numbers = list(range(1, 11)) odd_first_ten_numbers = [] for number in first_ten_numbers: if number % 2 == 1: odd_first_ten_numbers.append(number) second_ten_numbers = list(range(20, 21)) odd_second_ten_numbers = [] for number in second_ten_numbers: if number % 2 == 1: odd_second_ten_numbers.append(number) third_ten_numbers = list(range(20, 21)) odd_third_ten_numbers = [] for number in third_ten_numbers: if number % 2 == 1: odd_third_ten_numbers.append(number) Modifying multiple copies of a code snippet is laborious and presents a risk - some copies of the repeated code may be modified while others erroniously remain the same. A naive user or developer may assume that all copies of the similar code are performing the same task. Even if they are aware of the difference, they may be unable to tell if a difference between these copies is intentional or a mistake. Refactoring is the process of restructuring code without changing its behaviour. For example, converting a few lines of code with a common overall task into a function or class. If you refactor repetitive code into functions or classes, bug fixes or modifications need only be carried out once to change all implementations. New, intended behaviour is then consistently reflected by each call to the reusable function or class. Additionally, the intended functionality can be reflected by the functions name. def get_odd(numbers): odd_numbers = [] for number in first_ten_numbers: if number % 2 == 1: odd_first_ten_numbers.append(number) return odd_numbers first_ten_numbers = list(range(1, 11)) odd_first_ten_numbers = get_odd(first_ten_numbers) second_ten_numbers = list(range(20, 21)) odd_second_ten_numbers = get_odd(second_ten_numbers) third_ten_numbers = list(range(20, 21)) odd_third_ten_numbers = get_odd(third_ten_numbers) If the functionality of get_odd needs to be modified, it need only be done once. Additionally, this code is clearer and more concise. If two slightly different tasks must be carried out, you might: develop two functions containing the different elements of code, with names that express the difference in their purpose or add a parameter to your function that will allow a user to differentiate between the two tasks # Simple and modular def is_odd(number): if number % 2 == 1: return True else: return False def get_odd(list_of_numbers): odd_numbers = [] for number in list_of_numbers: if is_odd(number): odd_numbers.append(number) return odd_numbers def get_even(list_of_numbers): even_numbers = [] for number in list_of_numbers: if not is_odd(number): even_numbers.append(number) return even_numbers # More concise, but also more complex - not always good def get_numbers_with_parity(list_of_numbers, parity): numbers_with_parity = [] if parity == &quot;odd&quot;: remainder = 1 elif parity == &quot;even&quot;: remainder = 0 else: raise ValueError(&quot;parity must be &#39;odd&#39; or &#39;even&#39;&quot;) return [number for number in list_of_numbers if number % 2 == remainder] You should use your best judgement to decide which is most appropriate in a given situation. It can be difficult to decide when repetition warrants refactoring of code into reusable functions/classes. The Rule of Three suggests that if similar code has been written more than two times, then it is worth extracting its operation to a reproducible procedure (i.e. a function or class). 2.5.2 You Ain’t Gonna Need It While you should endeavour to capture your users needs in the functionality that your software provides, going beyond this may not be beneficial. I can be tempting to try to account for every eventuality in your program, or dive down an interesting There’s a good chance that many cases that you account for will never occur. This 2.5.3 Be Explicit In the literary sense of the word! “Explicit is better than implicit” — The Zen of Python (import this) In some programming languages, it is possible to perform a task or decision by relying on an implied parsing of your code. To make your intentions clear, you should explicitly state yout intentions in the code. coconut_count = None # Relying on falseness of None if coconut_count: print(&quot;There are &quot; + coconut_count + &quot; coconuts!&quot;) In the example above, the coconut count is not printed because None is evaluated to False. In python and R, 0 will also evaluate to False. It is unclear whether the programmer intended that the statement is printed when the count is 0. If a count of 0 should be printed, then this lack of specificity has created a bug. To perform the same decision explicitly, you could specify the exact condition under which the coconut count should be printed. coconut_count = 0 # Explicitly only print if not None if coconut_count is not None: print(&quot;There are &quot; + coconut_count + &quot; coconuts!&quot;) 2.6 SOLID Software Design SOLID is an acronym that encompasses 5 software design principles that are intended to increase the readability and extensibility of software source code. These principles are designed to improve object-orientated programs, but can be roughly applied to functional programs. 2.6.1 Single responsibility An object should have a single responsibility. Only changes to one part of the software’s specification should be able to affect the specification of the class. This principle suggests that a single element of your code (a function or class) should be responsible for a single part of your software’s funcitonality. It should take on one taks and perform it well. A piece of code is more robust if there are fewer reasons to change it in the future. Code that is responsible for multiple aspects of your softwares functionality might need modifying for several reasons. Because of this multitasking design, it is also likely to be more difficult to modify this code without having an unintentional effect on other aspects of the software. Applying this principle reduces the complexity of your code, as the task assigned to each function or class is clearly defined and is independent of other functions or classes. This simplicity also increases usability, by minising the number of parameters that each function or class might require. The Separation of Concerns priciple captures a similar concept to Single Responsibility, but on a higher level. This principle suggests that your software should be separated into distinct sections that each address a single concern. For example, if your software is responsible for managing sales of a product, then your concerns might include: - Presenting information to the customer, to allow them to select a product - Taking payment from the customer - Arranging dispatch and delivery of the product Within the section of you software that is responsible for taking payment, you might have multiple responsibilities: - collect the users input, to capture payment details - pass the payment information on to a third party, to process the payment - report the status of the payment to the user Figure 2.5: Representation of concerns and responsibilities within a piece of software As such, separate sections of your software should be responsible for each of the concerns. Within each section of your software, disctinct functions or classes should be responsible for each task that is required for that sections overall functionality. 2.6.2 Open-closed Objects and functions should be open for extension, but closed for modification This means that it should be possible to extend the functionality of classes or functions, without modifying their source code. For example, extension of a class or function could be carried out through subclassing or wrapper functions/decorators, respectively. 2.6.3 Liskov substitution Objects should be replaceable with instances of their subtypes, without altering the correctness of that program Subclasses should not damage the functionality of their parent class in their implementation. They should extend their usefulness, but retain their original functionality. 2.6.4 Interface segregation Many client-specific interfaces are better than one general-purpose interface As you add more and more functionality into a single interface, it becomes more difficult to extend or maintain. Separating these into multiple interfaces increases simplicity and maintainability. 2.6.5 Dependency inversion Depend on abstractions, not concretions High level modules should not depend on low-level modules. Both should depend on interfaces - i.e. be built with this interaction in mind. Abstractions should not depend on specific details. Concrete implementations should depend on abstractions. "]
]
