# Testing code

We use testing here to refer to code that aims to verify that your analytical code is working as expected. While code documentation specifies what you expect your code to do, testing assures that the action of the code meets these expectations.

## Introduction

The core concept of testing is **"Does my code do what I expect it to, given realistic inputs?"**.

Successfully delivering a completed piece of analysis or research includes both writing the code the carry out your analysis and assuring that it works. You can't be sure that your code works without having run it with realistic examples. Therefore, you must test the most complex and important parts of your analytical code.

Tests can:
* verify that users expectations are met by the code.
* let you know when you've broken the expected functionality of your code.
* be used to report or flag poor performance, for example, when modelling.

Testing is crucial to assuring quality in your code and will also increase efficiency in the development of your code. Code that has not been testing is more likely to contain bugs and require more maintenance in the future.

In the following sections we discuss good practices for writing automated code tests.

## Tests are structured

Tests comes in many shapes and sizes, but often follow the pattern:
1. Arrange - set up any objects for your test, e.g. example input data and expected output data.
2. Act - run the code that you are testing (1 or more functions or methods).
3. Assert - verify that the code performed the expected action, e.g. that the output matched the expected output.

We'll use a couple of examples throughout this section of the book, to demonstrate how tests relate to analytical code. Here we've a basic function to get the absolute equivalent of a number:

```py
def absolute(number):
    """Get the non-negative equivalent of a real number."""
    if not isinstance(number, (int, float)):
        raise TypeError("Input number must be numeric.")
    return (number * number) ** 0.5
```

To test that this function works as expected, we write another function to carry out the test. We've spread the code out over separate lines, to make it clear how this test follows the arrange, act, assert patten:

```py
def test_absolute_converts_negative_inputs():
    """Makes negative numbers positive."""
    # Arrange
    input_value = -5
    expected_output = 5
    # Act
    actual_output = absolute(input_value)
    # Assert
    assert actual_output == expected_output
```

The example above can be described as a 'unit test'. This means that it tests the smallest unit of our code - a function. There are three common "layers" of testing:

* Unit testing - assuring that functions or class methods perform as expected.
* Integration testing - assuring that units interact with other units or third party code as expected.
* End-to-end or system testing - assuring that a complete system functions as expected.
* User acceptance testing - assures that the system meets a users expectations.
[Acceptance testing](https://en.wikipedia.org/wiki/Acceptance_testing) is often considered as an additional level, and should be applied whenever developing software for specific users.

Later in this chapter, we describe what risk each level aims to address and detail good practices for each.


## Test data is minimal

- there should only be enough data to be able to carry out the test.
- data should be static (hardcoded), readable, fake and close to the tests (if unit test).
- expected output must not be generated by running your function then pasting it into the script. Strong indication that your function is too complicated.
- can reuse larger example data for multiple integration and end to end tests. Return it from a function or fixture for consistency.

## Test code is modular

Modular, well-structured code is easier to write tests for As such, testing encourages you to structure your code well.
Testing directories should mirror the source code directories. Might want one file per function/class or one per module.
Overall, it should be easy to identify which functions or classes your tests are assuring.

```
project/
│
├── src/
|   ├── __init__.py
│   ├── math.py
│   ├── strings.py
|   └── api.py
│
└── tests/
    |
    ├── unit/
    |   ├── __init__.py
    |   ├── test_math.py
    |   └── test_strings.py
    |
    ├── integration/
    |   ├── __init__.py
    |   └── test_sum.py
    |
    └── end_to_end/
        ├── __init__.py
        └── test_end_to_end.py
```

## Tests are specific

Tests should be specific.
If you can't refactor the code to make it easier to test specific aspects, then Mocks can be useful for removing unwanted factors.
Mocking is useful for removing things that we don't care about from the the test. But should not be used to avoid testing complex parts of code that you've written.

## Tests are independent

Tests should be clean and easy to maintain:
 - tests should be independent (no external state, if possible). You shouldn't need one to run before or after another - testing frameworks will often randomly order the tests when running them for this reason.
 - no side effects. Use set up and tear down to manage this. Or Mocks to avoid it.
 - should be independent to the code. Ideally, if the code changes, functions should not break. Difficult to do, but can create an interface between tests and main code base.

## Tests are documented

Test must describe what it is testing.
Ideally, do this using good naming practices within the test code. It should tell a story - given this data, having run this function, we expect this output.
If this is not clear from the code, us Python in function/method name, R in testthat... Use docstrings or comments where needed.
### Bugs are tested

Every time you find a bug, write a test.

### Tests are deterministic

Test should be deterministic and repeatable. The only thing that should cause a test to fail is if the tested code has changed. Running the same test with the same tested code should always produce the same outcome.
Tests should pass or fail, not "mostly pass".

## Tests are thorough but realistic

> A quality assurance engineer walks into a bar. They order 1 beer. They order 3.14 beers. They order -1 beers. They order 99999999999 beers. They order a lizard. They order `NULL`.  

> The first customer walks in and asks where the bathroom is. The bar bursts into flames.

Unfortunately, there's no golden rule for exactly what you should test.
We can use general guides to direct where most of our testing effort goes.

Types of test - positive, negative (errors, if API). positive, negative, 0, NA.

You should:
* Focus on testing the most complex and vulnerable parts of your code
* Write a new test every time you find a bug, to squash it for good
* Focus on testing the most realistic use cases of your code
* Test external interfaces - what happens if something unexpected is returned from one of your dependencies?
* Document what your code should and shouldn't be used for, to steer users towards the correct and tested usage

You shouldn't:
* Attempt to test every possible input and type of input
* Focus on things that are already sufficiently tested (e.g. it should not be necessary to test the functionality from your dependencies packages if you are confident that they are already been subjected to sufficient assurance)
* Write tests that have an element of randomness - tests should be deterministic


A short check-list for questions to ask when writing tests:
* Have I tested realistic combinations of my code's input parameters?
* Have I tested any discrete outputs once?
* Have I tested the boundaries of non-discrete outputs?
* Are informative errors raised when the code is not used in a valid or correct way?
* Are informative warnings raised when the code is not used in a standard way?


Don't worry if writing all of these tests sounds like a large task.
You'll find that tests are very repetitive in nature, so we can reuse testing code to broaden the cases that our tests cover.
We'll describe two useful ways of reducing the burden of writing and maintaining tests in a later section.

The examples in this section use these testing frameworks:
* `pytest` for Python
* `testthat` for R

R users might also be interested in `assertthat`, which provides Python-like assertions in R.

Other common frameworks, which have a Class-based focus, are:
* `unittest` built into Python
* `Runit` for R


```{todo}

Modelling-relevant testing
including https://www.jeremyjordan.me/testing-ml/

[#15](https://github.com/best-practice-and-impact/qa-of-code-guidance/issues/15)
```


## Test placeholders

Write test shells where you intend to write test - this highlights where testing is missing, easy to come back to later.
Or at least document these somewhere.

```console
$ pytest
...

snippets/pytest_example.py::test_absolute_converts_negative_inputs PASSED [ 25%]
snippets/pytest_example.py::test_absolute_non_negative_inputs PASSED     [ 50%]
snippets/pytest_example.py::test_absolute_non_numeric_raises PASSED      [ 75%]
snippets/pytest_example.py::test_absolute_na SKIPPED                     [100%]

===================== 3 passed, 1 skipped in 0.11 seconds =====================
```

## Test outcomes are recorded

CI is best, as it keeps testing close to version control.
Where manual testing is carried out, this must be documented to create an audit trail. This documentation should include what has been tested and who has approved that it works as expected.


## Tests are not repetitive

Where possible, reduce repetition in your tests.
Repetitive test code violates the "Don't repeat yourself" rule.
Don't need to be completely DRY, but repetition makes maintenance of test code more difficult and risky (as with non-test code).
As with functional code, test code is much easier to maintain when it is modular and reusable.

```{todo}
Add examples to reducing repetition in tests to demonstrate these

[#29](https://github.com/best-practice-and-impact/qa-of-code-guidance/issues/29)
```


### Fixtures

As your test suite grows, you might notice that many of your tests use similar code to prepare your tests or to clean up after each test has run.
Copying these code snippets for each test is laborious and also increases the risk of inconsistently applying those steps.

Fixtures help us to avoid this form of repetition in our tests.
You define your test preparation and clean up within a function (the fixture).
You then use the fixture to carry out these steps consistently for each test that they are required for. 

In Class-based testing frameworks, these functions tend to be separated into `SetUp` and `TearDown` functions.
These are similarly set to run before and after each test, respectively.

Fixtures can be especially useful when setting up a test object takes a large amount of time or resource.
They can be designed to run for each test, once for a group of tests or once for the whole test suite.
They are also useful for undoing any consequences of each test run.
For example, removing data which has been written to a temporary file or database.

Reference material:
* [Python `pytest` Fixture](https://docs.pytest.org/en/stable/fixture.html) documentation
* [R `testthat` Fixture](https://testthat.r-lib.org/articles/test-fixtures.html) documentation


### Parametrization

You might also find that similar steps are taken when testing multiple combinations of inputs and outputs.
Parametrization allows us to reduce repetition in our code, in a similar way to reusable functions.
We specify the pairs of inputs and expected outputs, so that our testing tool can repeat a test for each scenario.

Note that this approach is equivalent to using a for-loop to apply a test function over multiple inputs and expected outputs.
However, using functionality from test packages may improve running efficiency and the detail of subsequent test reports.

In `pytest`, this can be achieved using the [Parametrize mark](https://docs.pytest.org/en/stable/parametrize.html).

In R, the `patrick` package extends `testthat` to provide a [`with_parameters_test_that`](https://rdrr.io/cran/patrick/man/with_parameters_test_that.html) function to achieve this.


## Tests are run regularly

Tests should be run whenever you make changes to your project.
This ensures that changes do not break the existing, intended functionality of your code.
When tests fail, you should endeavour to fix these before adding these changes to a stable or production version of your code.

If you have intentionally altered the functionality of your code, this will likely break existing tests.
Failing tests here are a good reminder that your should update your documentation and tests to reflect the new functionality.

If your collection of tests runs quickly, it's simplest to run them all often.
If some tests take considerably longer to run, you might want to run these less often - perhaps only when relevant changes have been made.
Otherwise, running the entire collection of tests has the added benefit of capturing unexpected side-effects of your changes.
For example, you might pick up an unexpected failure in part of your code that you have not directly changed.

It's not easy to remember to run your tests at regular intervals.
You're already putting effort into `commit`ing your changes to a version control system regularly.
And you're right to think "surely this could be automated too?"
[Continuous integration](continuous-integration) can be used to automate testing, amongst other quality assurance measures, and can be triggered when changes are made to your remote version control repository.
These tools can be used to ensure that all changes to a particular project are tested.
Additionally, it allows others that are reviewing your code to see the results of your tests.

An alternative to continuous integration, is using a Git hook.
[Git hooks](https://git-scm.com/docs/githooks) are scripts that can be set to run locally at specific points in your Git workflow.
For example, we might set up a `pre-commit` or `pre-push` hook that runs our tests before we make each commit or push to the remote repository.
This might stop our commit/push if the tests fail, so that we don't push breaking changes to our remote repository.

```{note}
If your code is likely to be run on a range of software versions or operating systems, you might want to test on a variety of these. Tools exists to support local testing of combinations software versions and package dependency versions:
* [tox](https://tox.readthedocs.io/en/latest/) or [nox](https://nox.thea.codes/en/stable/) for Python
* [rhub](https://r-hub.github.io/rhub/) for R

However, [continuous integration](continuous-integration) can be used to automate these tests on a broader range on parameters.
```

## Testing at multiple levels

Each level is important for different reasons.

### Unit testing


```{admonition} Key Learning
:class: admonition-learning

You should follow the [Introduction to Unit Testing course](https://learninghub.ons.gov.uk/enrol/index.php?id=539) (GSS only) for applied examples in Python and R.
The course also covers writing and documenting functions, and error handling.

Other resources include:
* Hadley Wickham's [testthat: getting started with testing](https://vita.had.co.nz/papers/testthat.pdf)
* [`pytest` getting started](https://docs.pytest.org/en/3.0.1/getting-started.html)
* Real Python [Getting Started With Testing in Python](https://realpython.com/python-testing/)
```

```{todo}
These testing sections all need more content/examples.

[#28](https://github.com/best-practice-and-impact/qa-of-code-guidance/issues/28)
```

### Integration testing

Your analysis likely involves multiple units working together to perform a high level task.
Assuring that individual units work as expected, using unit testing, does not guarantee that multiple units interact with one another as expected.

```{figure} ./_static/no_integration_tests.png
---
width: 40%
name: no_integration_tests
alt: Two drawers that open into each other's handles.
---
Two unit tests, no integration tests.
```

Integration tests incorporate two or more units and check that they work together correctly.
These tests are also used to test the interface between your code and external dependencies, such as a database or web-based API.

When your code relies upon interaction with complex or external dependencies, it may be difficult for your tests to reproducibly access these dependencies.
Creating abstractions of these dependencies when they are not being directly tested can keep your test code simpler and more focused.
You might use Stubs or Mocks for this purpose:
* Stubs carry out a predetermined behaviour. For example, a stub representing an API always returns the same response. Use these when you are not interested in the details around how your code interacts with the dependency.
* Mocks require additional setup in your test code, to define your expectations. Use these when your test needs to verify that your code interacts with the Mock in a specific way.


### End-to-end testing

As the name suggests, these tests cover the entire process.
The motivation for using end-to-end tests is similar to that of integration tests.
Despite assurance that small sections of the code are functioning correctly, it's important to validate that your overall system is fit for purpose.

```{figure} https://i.stack.imgur.com/Nirxy.jpg
---
width: 50%
name: sinking_ship
alt: A sinking ship would still report passing unit tests.
---
A sinking ship would still report a number of passing unit and integration tests, while the system is failing overall.
```

These tests are much slower to run and can take longer to develop for complex processes.
Having at least one end-to-end test for your process will ensure that the high-level specification of your code is met.
This should validate that your user requirements are met.

### Acceptance testing

Assures that code works for your end-user's requirements.
